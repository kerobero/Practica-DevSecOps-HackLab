name: devsecops-pipeline

on:
  pull_request:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  packages: write   # Ãºtil si luego publicas en GHCR
  discussions: write
  pull-requests: write

concurrency:
  group: devsecops-${{ github.ref }}
  cancel-in-progress: true

env:
  # ğŸ” Cambia esto para probar cada escenario (apps/10-secrets-leak, 20-sast-bugs, etc.)
  APP_DIR: apps/10-secrets-leak
  # ParÃ¡metros de despliegue local
  IMAGE_NAME: demo-app
  IMAGE_TAG: local
  KIND_CLUSTER: kind-devsecops
  SERVICE_RELEASE_NAME: demo

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Secrets + SAST
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  secrets:
    name: Secrets scanning (Gitleaks)
    runs-on: self-hosted
    steps:
      - name: Clean gitleaks
        run: rm -f /tmp/gitleaks.tmp   
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # para anÃ¡lisis que miran historial
      - name: Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # Si usas un gitleaks.toml propio, aÃ±ade inputs/vars segÃºn la acciÃ³n

  sast:
    name: SAST (Semgrep)
    runs-on: self-hosted
    needs: [secrets]
    steps:
      - uses: actions/checkout@v4
      - name: Semgrep (no bloqueante)
        run: |
          docker run --rm -v "$PWD:/src" returntocorp/semgrep:latest \
            semgrep scan --config p/ci --config .semgrep
      - name: Export SARIF (para pestaÃ±a Security)
        run: |
          docker run --rm -v "$PWD:/src" returntocorp/semgrep:latest \
            semgrep scan --config p/ci --config .semgrep --sarif -o semgrep.sarif || true
      - uses: github/codeql-action/upload-sarif@v3
        with: { sarif_file: semgrep.sarif }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # IaC + Build + SBOM
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # iac:
  #   name: IaC scan (Checkov)
  #   runs-on: self-hosted
  #   needs: [sast]
  #   steps:
  #     - uses: actions/checkout@v4
  #     - name: Checkov (K8s/Terraform)
  #       uses: bridgecrewio/checkov-action@master
  #       with:
  #         directory: .
  #         quiet: true
  #         soft_fail: false     # pon true si no quieres bloquear (no recomendado)

 
  docker:
    runs-on: ubuntu-latest
    needs: [sast]
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: kerobero/demo-app:local

  build:
    name: Build + SBOM
    runs-on: self-hosted
    needs: [sast]
    steps:
      - uses: actions/checkout@v4
      - name: Build imagen de la app objetivo
        run: |
          cd "${APP_DIR}"
          docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
          echo ${IMAGE_NAME}
          echo ${IMAGE_TAG}
      - name: SBOM (Syft)
        uses: anchore/sbom-action@v0
        with:
          image: demo-app:local
          artifact-name: sbom.spdx.json   # queda como artefacto del job
 